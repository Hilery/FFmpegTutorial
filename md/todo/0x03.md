# 播放器驱动

播放器的一个核心部件是驱动，我们要设计一套良好的驱动系统，用来管理读包-解码-播放流程，这其实是一个生产者与消费者链的关系！

```
渲染线程 消耗 解码线程的产物 --- 帧数据
解码线程 消耗 读包线程的产物 --- 数据包
```
渲染只能在主线程里做，为了尽可能利用设备资源，所以解码和读包应当各自起一个线程去完成，所以就是三个线程，两个缓存区。

我的设计思路如下:

```
|-------------->------------------->--------------
|主线程定时渲染	
|	通过定时器驱动，如果可播放则消耗frame-buffer里的帧；
|	根据该帧的显示时间设定定时器下一次触发时间；
|	如果不可播放则每隔0.1s轮询，直到可播放为止；
|--------------<-------------------<--------------
	
||
↓↓ (frame-buffer不满时就唤醒解码线程)
↓↓     [frame,...]
||

|-------------->------------------->--------------
|解码线程
|	一直解码，直到frame-buffer满或者packet-buffer消
|	耗殆尽为止；每解码一帧就检查是否可播放的标志位，之前
|	不可播放时就重新计算是否可播放
|--------------<-------------------<--------------

||
↓↓ (packet-buffer不满时就唤醒读包线程)
↓↓     [packet,...]
||

|-------------->------------------->--------------
|读包线程
|	一直读，直到读完或者packet-buffer满为止；每读到一包
|	就唤醒解码线程去解码，具体是否需要解码是解码线程的事；   
|--------------<-------------------<--------------
	
```

我也是第一设计这样的驱动，不足之处尽管提出。

这篇教程主要设计这个驱动，下一篇会把解码后的帧渲染到相应的view上，后续教程会使用不同的技术把avframe帧进一步转换成和View配套的帧，具体看后面的教程!

如果没有这个驱动，后续就无法对比不同方案的渲染情况，运行后查看内存是稳定，并且暂用不大，可根据硬件实际情况调整缓存大小。